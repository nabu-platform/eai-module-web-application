/*
* Copyright (C) 2016 Alexander Verbruggen
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program. If not, see <https://www.gnu.org/licenses/>.
*/

package be.nabu.eai.module.web.application;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.text.ParseException;
import java.util.function.Function;

import javax.xml.bind.annotation.XmlRootElement;

import be.nabu.libs.cache.api.DataSerializer;
import be.nabu.libs.types.ComplexContentWrapperFactory;
import be.nabu.libs.types.TypeUtils;
import be.nabu.libs.types.api.ComplexContent;
import be.nabu.libs.types.api.ComplexType;
import be.nabu.libs.types.api.ModifiableComplexType;
import be.nabu.libs.types.api.ModifiableComplexTypeGenerator;
import be.nabu.libs.types.binding.api.Window;
import be.nabu.libs.types.binding.xml.XMLBinding;
import be.nabu.libs.types.definition.xml.XMLDefinitionMarshaller;
import be.nabu.libs.types.definition.xml.XMLDefinitionUnmarshaller;
import be.nabu.libs.types.java.BeanResolver;

/**
 * A special serializer that serializes both the content _and_ the definition
 * This is meant for dynamic content that has no fixed definition but still needs correct unmarshalling. 
 * For example take a session, it is a dynamic key value map where you can put anything. How to correctly deserialize that from bytes?
 * 
 * For example if we serialize a token generated by CMS, we might get:

<structure name="anonymous">
    <structure definition="be.nabu.libs.authentication.api.TokenWithSecret" name="token.crm"/>
</structure>

<anonymous xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<token.crm>
		<name>alexander.verbruggen@example.com</name>
		<credentials xsi:type="be.nabu.libs.http.glue.impl.UserMethods$BasicPrincipalImplementation">
			<name>alexander.verbruggen@example.com</name>
			<password>test</password>
			<device xsi:type="be.nabu.libs.authentication.impl.DeviceImpl">
				<deviceId>beea5b79ddcf44988242475b7ff1234e</deviceId>
				<remoteHost>ip6-localhost</remoteHost>
				<deviceDescription>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/68.0.3440.75 Chrome/68.0.3440.75 Safari/537.36</deviceDescription>
			</device>
		</credentials>
		<realm>crm</realm>
		<secret>ceea5b79ddcf44988242475b7ff1234e</secret>
	</token.crm>
</anonymous>

 */
public class UndefinedSerializer implements DataSerializer<Object> {

	private XMLBinding binding;
	private ModifiableComplexTypeGenerator generator;
	private Function<Object, Object> transformer;

	public UndefinedSerializer(ModifiableComplexTypeGenerator generator, Function<Object, Object> transformer) {
		this.generator = generator;
		this.transformer = transformer;
		this.binding = new XMLBinding((ComplexType) BeanResolver.getInstance().resolve(UndefinedInstance.class), Charset.forName("UTF-8"));
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public void serialize(Object object, OutputStream output) throws IOException {
		UndefinedInstance marshal = marshal(object, generator);
		binding.marshal(output, ComplexContentWrapperFactory.getInstance().getWrapper().wrap(marshal));
	}

	@Override
	public Object deserialize(InputStream input) throws IOException {
		try {
			ComplexContent unmarshal = binding.unmarshal(input, new Window[0]);
			UndefinedInstance undefined = TypeUtils.getAsBean(unmarshal, UndefinedInstance.class);
			Object unmarshalled = unmarshal(undefined, generator);
			if (transformer != null) {
				unmarshalled = transformer.apply(unmarshalled);
			}
			return unmarshalled;
		}
		catch (ParseException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
	public Class<Object> getDataClass() {
		return Object.class;
	}
	
	@XmlRootElement(name = "undefined")
	public static class UndefinedInstance {
		private byte [] definition, instance;
		
		public byte[] getDefinition() {
			return definition;
		}
	
		public void setDefinition(byte[] definition) {
			this.definition = definition;
		}
	
		public byte[] getInstance() {
			return instance;
		}
	
		public void setInstance(byte[] instance) {
			this.instance = instance;
		}
	}
	
	@SuppressWarnings("unchecked")
	public static UndefinedInstance marshal(Object object, ModifiableComplexTypeGenerator typeGenerator) throws IOException {
		ComplexContent content = object instanceof ComplexContent ? (ComplexContent) object : ComplexContentWrapperFactory.getInstance().getWrapper().wrap(object);
		
		// only xml binding allows for XSI-based overrides of types
		// otherwise we might have problems with deserializing interfaces etc (e.g. credentials in a token)
		XMLBinding binding = new XMLBinding(content.getType(), Charset.forName("UTF-8"));
		
		ByteArrayOutputStream output = new ByteArrayOutputStream();
		binding.marshal(output, content);
		
		UndefinedInstance undefined = new UndefinedInstance();
		undefined.setInstance(output.toByteArray());
		
		XMLDefinitionMarshaller marshaller = new XMLDefinitionMarshaller();
		output = new ByteArrayOutputStream();
		marshaller.marshal(output, content.getType());
		
		undefined.setDefinition(output.toByteArray());
		
		return undefined;
	}
	
	public static Object unmarshal(UndefinedInstance undefined, ModifiableComplexTypeGenerator typeGenerator) throws IOException, ParseException {
		XMLDefinitionUnmarshaller unmarshaller = new XMLDefinitionUnmarshaller();
		
		ModifiableComplexType complexType = typeGenerator.newComplexType();
		unmarshaller.unmarshal(new ByteArrayInputStream(undefined.getDefinition()), complexType);
		
		XMLBinding binding = new XMLBinding(complexType, Charset.forName("UTF-8"));
		// normally everything that expects complex content can transform
		// everything that expects beans however generally can't
		binding.setUnwrapBeans(true);
		
		return binding.unmarshal(new ByteArrayInputStream(undefined.getInstance()), new Window[0]);
	}
}
